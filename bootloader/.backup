;
; main.asm - FAT16 Bootloader
; Created By Matheus Leme Da Silva
;

[BITS 16]

%define FILE_ADDR 0x1000

global _start
jmp short _start
nop

oem_id               db 'Rux OS  '     ; OEM identifier (8 bytes)
bytes_per_sector     dw 0x0200         ; Standard for most systems
sectors_per_cluster  db 0x20           ; Increased for 32MB volume
reserved_sectors     dw 0x0001         ; Space for bootloader
fat_count            db 0x02           ; Standard (2 FAT copies)
root_entries         dw 0x0400         ; Root directory entries (1024 in hex)
total_sectors        dw 0xFFFF         ; Max for FAT16 with 16-bit field
media_type           db 0xF8           ; Fixed disk
sectors_per_fat      dw 0x0040         ; Adjusted for larger volume (64 in hex)
sectors_per_track    dw 0x003F         ; Standard for modern disks (63 in hex)
heads                dw 0x00FF         ; Common standard (255 in hex)
hidden_sectors       dd 0x00000000     ; No hidden sectors
large_sectors        dd 0x00000000     ; Not used (total_sectors < 65536)
drive_number         db 0x80           ; First hard disk
reserved             db 0x00           ; Reserved byte
signature            db 0x29           ; Extended signature
volume_id            dd 'RUX '         ; Volume ID
volume_label         db 'RUX OS     '  ; Volume label (11 bytes)
system_id            db 'FAT16   '     ; Filesystem type

_start:
    cli
    mov ax, 0x07C0       ; Set up segments
    mov ds, ax
    mov es, ax
    xor ax, ax
    mov ss, ax
    mov sp, 0xFFFF
    sti

    mov [drive_number], dl ; Save boot drive
    
    mov si, boot_msg
    call print

    ; Calculate start of root directory
    movzx ax, byte [fat_count]
    mul word [sectors_per_fat]  ; AX = fats * sectors_per_fat
    add ax, [reserved_sectors]  ; Add reserved sectors
    mov [root_dir_start], ax

    ; Calculate root directory size in sectors
    mov ax, [root_entries]
    mov cx, 0x20         ; 32 bytes per entry
    mul cx
    div word [bytes_per_sector]
    test dx, dx
    jz .no_round
    inc ax
.no_round:
    mov [root_dir_sectors], ax
    
    ; Calculate data area start
    mov cx, ax           ; Save root_dir_sectors
    add ax, [root_dir_start]
    mov [data_start], ax

    ; Load root directory
    mov ax, [root_dir_start]
    mov bx, buffer
    call read_sectors

    ; Find kernel file
    mov cx, [root_entries]
    mov di, buffer
    
.find_file:
    cmp byte [di], 0     ; End of directory?
    je .not_found
    
    cmp byte [di], 0xE5  ; Deleted entry?
    je .next

    mov si, filename     ; Compare filename
    push di
    mov cx, 0x0B         ; 11 em hex
    repe cmpsb
    pop di
    je .found
    
.next:
    add di, 0x20         ; Next entry (32 em hex)
    dec word [counter]
    jnz .find_file

.not_found:
    mov si, not_found
    call print
    jmp reboot

.found:
    ; Get first cluster
    mov ax, [di+0x1A]    ; 26 em hex
    mov [cluster], ax

    ; Load FAT
    mov ax, [reserved_sectors]
    mov cx, [sectors_per_fat]
    mov bx, fat_buffer
    call read_sectors

    ; Set up destination buffer
    mov ax, FILE_ADDR
    mov es, ax
    xor bx, bx

.load_loop:
    mov ax, [cluster]
    cmp ax, 0x0002       ; Valid cluster?
    jb .done
    cmp ax, 0xFFF8       ; End of file? 
    jae .done

    ; Convert cluster to LBA
    sub ax, 0x0002
    movzx cx, byte [sectors_per_cluster]
    mul cx
    add ax, [data_start]
    
    ; Read cluster
    push bx
    movzx cx, byte [sectors_per_cluster]
    call read_sectors
    pop bx

    ; Update buffer position
    movzx ax, byte [sectors_per_cluster]
    mul word [bytes_per_sector]
    add bx, ax
    
    jnc .no_adj
    
    ; Adjust segment if overflow
    mov dx, es
    add dx, 0x1000
    mov es, dx
    xor bx, bx
    
.no_adj:
    ; Get next cluster
    mov ax, [cluster]
    shl ax, 1            ; Multiply by 2 (FAT16 = 2 bytes per entry)
    add ax, fat_buffer
    mov si, ax
    mov ax, [si]
    mov [cluster], ax
    
    jmp .load_loop

.done:
    mov si, ok_msg
    call print
    mov dl, [drive_number]
    jmp FILE_ADDR:0000   ; Jump to loaded file

; Read sectors function
; AX=LBA, CX=sectors to read, ES:BX=buffer
read_sectors:
    pusha
    
.read:
    push cx
    push ax

	push ax
	mov ah, 0x0E
	mov al, '.'
	int 0x10
	pop ax
    
    ; Convert LBA to CHS
    xor dx, dx
    div word [sectors_per_track]
    inc dl               ; Sector = (LBA % SPT) + 1
    mov cl, dl
    
    xor dx, dx
    div word [heads]
    mov dh, dl           ; Head
    mov ch, al           ; Cylinder (low 8 bits)
    
    shl ah, 6            ; High 2 bits of cylinder
    or cl, ah
    
    mov dl, [drive_number]
    mov ax, 0x0201       ; Read 1 sector
    
    int 0x13
    jc .error
    
    pop ax
    inc ax               ; Next sector
    add bx, [bytes_per_sector]
    
    pop cx
    loop .read
    
    popa
    ret

.error:
    mov si, err_msg
    call print
    jmp reboot

print:
    lodsb
    test al, al
    jz .done
    mov ah, 0x0E
    int 0x10
    jmp print
.done:
    ret

reboot:
    mov si, key_msg
    call print
    xor ah, ah
    int 0x16            ; Wait for key
    int 0x19            ; Reboot

; Data
boot_msg    db 'Booting...',0
err_msg     db 'Err',0
not_found   db 'No File',0
ok_msg      db 'OK',0
key_msg     db '*',0
filename    db 'RUX-16  SYS'     ; 8.3 filename format

root_dir_start  	dw 0
root_dir_sectors 	dw 0
data_start      	dw 0
cluster         	dw 0
counter         	dw 0x0200        ; 512 em hex

times 510-($-$$) db 0
dw 0xAA55

buffer:
fat_buffer:
